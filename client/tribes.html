<html lang="en">
	<head>
		<title>three.js - misc - octree collisions</title>
		<meta charset=utf-8 />
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
        <script src="./lib/geckos.io-client.2.3.0.min.js"></script>

	</head>
	<body>
        <div id="hudbox">
            <div id="hud">HUD</div>
        </div>
		<div id="container"></div>

		<!-- Import maps polyfill -->
		<!-- Remove this when import maps will be widely supported -->
		<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

		<script type="importmap">
			{
				"imports": {
					"three": "./lib/three.module.js",
					"three/addons/": "./lib/jsm/"
				}
			}
		</script>

		<script type="module">

import * as THREE from 'three';
import Stats from 'three/addons/libs/stats.module.js';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { Octree } from 'three/addons/math/Octree.js';
import { OctreeHelper } from 'three/addons/helpers/OctreeHelper.js';
import { Capsule } from 'three/addons/math/Capsule.js';
import { clone } from 'three/addons/utils/SkeletonUtils.js';
import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
import { Water } from 'three/addons/objects/Water.js';
import { Sky } from 'three/addons/objects/Sky.js';
import gamestate from "./common/gamestate.mjs";

var pad = null;

window.addEventListener("gamepadconnected", (e) => {
    pad = e.gamepad;
    console.log("Gamepad connected at index %d: %s. %d buttons, %d axes.",
        e.gamepad.index, e.gamepad.id,
        e.gamepad.buttons.length, e.gamepad.axes.length);
});

var gameState = new gamestate();

const clock = new THREE.Clock();
const scene = new THREE.Scene();

scene.background = new THREE.Color( 0x88ccee );
scene.fog = new THREE.Fog( 0x88ccee, 0, 150 );

const camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 1000 );
camera.rotation.order = 'YXZ';

const fillLight1 = new THREE.HemisphereLight( 0x4488bb, 0x002244, 0.5 );
fillLight1.position.set( 2, 1, 1 );
scene.add( fillLight1 );

const solar = {
	elevation: 2,
	azimuth: 180,
    radius: 100
};

let phi = THREE.MathUtils.degToRad( 90 - solar.elevation );
let theta = THREE.MathUtils.degToRad( solar.azimuth );

const directionalLight = new THREE.DirectionalLight( 0xffffff, 0.8 );
directionalLight.position.setFromSphericalCoords( solar.radius, phi, theta );
directionalLight.castShadow = true;
directionalLight.shadow.camera.near = 0.01;
directionalLight.shadow.camera.far = 500;
directionalLight.shadow.camera.right = 30;
directionalLight.shadow.camera.left = - 30;
directionalLight.shadow.camera.top	= 30;
directionalLight.shadow.camera.bottom = - 30;
directionalLight.shadow.mapSize.width = 1024;
directionalLight.shadow.mapSize.height = 1024;
directionalLight.shadow.radius = 4;
directionalLight.shadow.bias = - 0.00006;
scene.add( directionalLight );

const container = document.getElementById( 'container' );
const hud = document.getElementById( 'hud' );

const renderer = new THREE.WebGLRenderer( { antialias: true } );
renderer.setPixelRatio( window.devicePixelRatio );
renderer.setSize( window.innerWidth, window.innerHeight );
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.VSMShadowMap;
renderer.outputEncoding = THREE.sRGBEncoding;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
container.appendChild( renderer.domElement );

const stats = new Stats();
stats.domElement.style.position = 'absolute';
stats.domElement.style.top = '0px';
container.appendChild( stats.domElement );

const GRAVITY = 30;

const NUM_SPHERES = 100;
const SPHERE_RADIUS = 0.2;
const STEPS_PER_FRAME = 5;

const WATER_PLANE_HEIGHT = -15;

const WALKER_SPAWN_RADIUS = 60;
const WALKER_SPAWN_SPEED = 150;
const WALKER_SPAWN_ANGLE = 75 * Math.PI / 180;
const WALKER_GRAV_MULTIPLIER = 4;
const WALKER_PERCENT_CHANCE = 75;

const sphereGeometry = new THREE.IcosahedronGeometry( SPHERE_RADIUS, 5 );
const sphereMaterial = new THREE.MeshLambertMaterial( { color: 0xbbbb44 } );

const NUM_PLAYERS = 10;
const PLAYER_RADIUS = 0.4;
var playerGeometry = new THREE.IcosahedronGeometry( PLAYER_RADIUS, 5 );
const playerMaterial = new THREE.MeshLambertMaterial( { color: 0x44aa22 } );

const BALL_REFIRE_RATE = 0.100; // 100 ms
let time_since_last_ball = 0;

const spheres = [];
let sphereIdx = 0;


for ( let i = 0; i < NUM_SPHERES; i ++ ) {
    const sphere = new THREE.Mesh( sphereGeometry, sphereMaterial.clone() );
    sphere.castShadow = true;
    sphere.receiveShadow = true;

    scene.add( sphere );

    spheres.push( {
        mesh: sphere,
        collider: new THREE.Sphere( new THREE.Vector3( 0, - 100, 0 ), SPHERE_RADIUS ),
        active: false,
        velocity: new THREE.Vector3()
    } );
}

const playerSpheres = [];
const playerMixers = [];
let animation = null;
let playerSphereIdx = 0;

let sun = new THREE.Vector3();
const waterGeometry = new THREE.PlaneGeometry( 10000, 10000 );
//waterGeometry.position.setY(-16.);
waterGeometry.translate(0., 0., WATER_PLANE_HEIGHT);
let water = new Water(
	waterGeometry,
	{
		textureWidth: 512,
		textureHeight: 512,
		waterNormals: new THREE.TextureLoader().load( 'assets/textures/waternormals.jpg', function ( texture ) {

			texture.wrapS = texture.wrapT = THREE.RepeatWrapping;

		} ),
		sunDirection: new THREE.Vector3(),
		sunColor: 0xffffff,
		waterColor: 0x004488, // tutorial nasty-water color is 0x001e0f,
		distortionScale: 3.7,
		//fog: scene.fog !== undefined
        fog: false
	}
);

water.rotation.x = - Math.PI / 2;
scene.add( water );

// Skybox

const sky = new Sky();
sky.scale.setScalar( 10000 );
scene.add( sky );

const skyUniforms = sky.material.uniforms;

skyUniforms[ 'turbidity' ].value = 10;
skyUniforms[ 'rayleigh' ].value = 2;
skyUniforms[ 'mieCoefficient' ].value = 0.005;
skyUniforms[ 'mieDirectionalG' ].value = 0.8;

const pmremGenerator = new THREE.PMREMGenerator( renderer );
let renderTarget;

function updateSun() {

	const phi = THREE.MathUtils.degToRad( 90 - solar.elevation );
	const theta = THREE.MathUtils.degToRad( solar.azimuth );

	sun.setFromSphericalCoords( solar.radius, phi, theta );

	sky.material.uniforms[ 'sunPosition' ].value.copy( sun );
	water.material.uniforms[ 'sunDirection' ].value.copy( sun ).normalize();

	if ( renderTarget !== undefined ) renderTarget.dispose();

	renderTarget = pmremGenerator.fromScene( sky );

	scene.environment = renderTarget.texture;

}

updateSun();

let pantsGeometry = null;
let pantsSkinnedMesh = null;
let pantsAnimation = null;

const loader = new GLTFLoader().setPath( './assets/models/' );

loader.load( './SimpleSkinning.gltf', (gltf) => {
    //gltf.position.set(0, -100, 0);



    gltf.scene.traverse( function ( child ) {
        if ( child.isSkinnedMesh ) {
            child.castShadow = true;
            child.skeleton.bones[0].scale.set(SPHERE_RADIUS, SPHERE_RADIUS, SPHERE_RADIUS);
        }
    } );

    let mixer = new THREE.AnimationMixer( gltf.scene );
    pantsAnimation = gltf.animations[0];
    mixer.clipAction( pantsAnimation ).play();
    playerMixers.push(mixer);

    let pantsGroup = new THREE.Group();
    pantsGroup.add(gltf.scene);
    pantsGroup.position.set(0.9, -1, 0);
    pantsGeometry = pantsGroup;
    pantsSkinnedMesh = gltf.scene;

    scene.add( pantsGroup );


    loadBaddies();

    loadSpinDisc();
});

//var baddieGeometry = new THREE.IcosahedronGeometry( PLAYER_RADIUS, 5 );
const baddyDummy = new THREE.Object3D();
const NUM_BADDIES = 200;
const BADDIE_SPEED = 10;
var baddiesToKill = NUM_BADDIES;
var baddiesKilled = 0;
var baddieLevelsCleared = 0;
var baddyMesh;
var baddieIdx = 0;
var baddies = [];

const baddieLookAt = new THREE.Vector3();
const baddieDeadPos = new THREE.Vector3(0, -200, 0);
const baddieFullColor = new THREE.Color(1, 1, 1);
const baddieDeadColor = new THREE.Color(1, 0, 0);
const baddieCurrentColor = new THREE.Color(1, 1, 1);



function loadBaddies() {
    loader.load( './baddie.glb', (baddie) => {
    //scene.add( baddie.scene );

    //gltf.position.set(0, -100, 0);

    let badStuff = baddie.scene;

    let baddieMeshLocal, baddieMaterialLocal;

    baddie.scene.traverse( function ( child ) {
        if ( child.isMesh ) {
            baddieMeshLocal = child;
            baddieMaterialLocal = child.material;
            badStuff = child;
            child.castShadow = true;
            child.receiveShadow = true;

            if ( child.material.map ) {
                child.material.map.anisotropy = 4;
            }
        }
    } );

    baddieMaterialLocal = new THREE.MeshPhysicalMaterial();
    baddieMaterialLocal.reflectivity = 0.5;
    baddieMaterialLocal.transmission = 0.5;
    baddieMaterialLocal.roughness = 0.2;
    baddieMaterialLocal.metalness = 0.9;
    baddieMaterialLocal.clearcoat = 0.3;
    baddieMaterialLocal.clearcoatRoughness = 0.25;
    baddieMaterialLocal.color = new THREE.Color(0xffffff);
    baddieMaterialLocal.ior = 1.2;
    baddieMaterialLocal.thickness = 5.0;


    baddyMesh = new THREE.InstancedMesh(baddieMeshLocal.geometry, baddieMaterialLocal, NUM_BADDIES);
    baddyMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

    let px, py, pz;
    for(let i = 0; i < NUM_BADDIES; i++) {
        let newbaddie = {
            index: i,
            position: [px, py, pz],
            collider: new THREE.Sphere( new THREE.Vector3( px, py, pz ), PLAYER_RADIUS * 3),
            velocity: new THREE.Vector3(),
            active: true,
            health: 100,
            flies: false,
            kill: function(send = false) {
                this.active = false;
                this.health = 0;
                this.collider.center.copy(baddieDeadPos);
                baddyDummy.position.copy(baddieDeadPos);
                baddyDummy.updateMatrix();
                baddyMesh.setMatrixAt(this.index, baddyDummy.matrix);
                baddyMesh.setColorAt(this.index, baddieDeadColor);
                if (channel && send) {
                    channel.emit("kill", this.index);
                }
            },
            revive: function(send = false) {
                this.active = true;
                this.health = 100;
                this.flies = WALKER_PERCENT_CHANCE < THREE.MathUtils.randFloat(0.,100.);

                if (this.flies) {
                    let rad = 50.;
                    this.position = [THREE.MathUtils.randFloat(-rad, rad), THREE.MathUtils.randFloat(0, 25), THREE.MathUtils.randFloat(-rad, rad) ];
                    this.velocity = new THREE.Vector3();
                } else {
                    //let heading = THREE.MathUtils.randFloat(0., 2*Math.PI);
                    let heading = THREE.MathUtils.randFloat(0., 0.3) - 0.15 - Math.PI/2;
                    let c = Math.cos(heading);
                    let s = Math.sin(heading);

                    let sx = c * WALKER_SPAWN_RADIUS;
                    let sy = WATER_PLANE_HEIGHT + 5;
                    let sz = s * WALKER_SPAWN_RADIUS;

                    let rise = Math.sin(WALKER_SPAWN_ANGLE) * WALKER_SPAWN_SPEED;
                    let run  = Math.cos(WALKER_SPAWN_ANGLE) * WALKER_SPAWN_SPEED;

                    let vx = -c * run;
                    let vy = rise;
                    let vz = -s * run;

                    this.position = [sx, sy, sz];
                    this.velocity = new THREE.Vector3(vx, vy, vz);
                }

                //console.log(`Setting baddie ${this.index}'s position to ${this.position}`);
                this.collider.center.set(...this.position);

                baddyDummy.position.set(...this.position);
                baddyDummy.updateMatrix();
                baddyMesh.setMatrixAt(this.index, baddyDummy.matrix);
                baddyMesh.setColorAt(this.index, baddieFullColor);

                if (channel & send) {
                    channel.emit("revive", this.index);
                }
            }
        };
        newbaddie.revive(false);
        baddies.push(newbaddie);
    }
    scene.add(baddyMesh);

    resetBaddies();

    /*
    const badboi = badStuff.clone();
    //badboi.scale.set(0.1, 0.1, 0.1);
    //badboi.position.set(0, -100, 0);

    const badGroup = new THREE.Group();
    badGroup.add(badboi);

    let clonedPants = clone(pantsSkinnedMesh);
    //scene.add(clonedPants);

    let pantsGroup = new THREE.Group();
    pantsGroup.add(clonedPants);
    pantsGroup.position.set(0.9, -1, 0);
    scene.add(pantsGroup);

    badGroup.add(pantsGroup);

    //badboi.add(pantsGeometry);

    scene.add( badGroup );

    let mixer = new THREE.AnimationMixer( clonedPants );
    mixer.clipAction( pantsAnimation ).play();
    playerMixers.push(mixer);

    baddies.push( {
            mesh: badGroup,
            collider: new THREE.Sphere( new THREE.Vector3( 0, - 100, 0 ), PLAYER_RADIUS ),
            velocity: new THREE.Vector3()
        } );

    for ( let i = 0; i < NUM_BADDIES; i ++ ) {
        const bg = badGroup.clone();

        //bg.position.set(0, -100, 0);

        scene.add( bg );

        baddies.push( {
            mesh: bg,
            collider: new THREE.Sphere( new THREE.Vector3( 0, - 100, 0 ), PLAYER_RADIUS ),
            velocity: new THREE.Vector3()
        } );
    }
    */

});
}

function resetBaddies() {
    let baddiesToRevive = gameState.getBaddiesRemaining();
    for(let i = 0; i < NUM_BADDIES && i < baddiesToRevive; i++) {
        baddies[i].revive();
    }
    for(let i = baddiesToRevive; i < NUM_BADDIES; i++) {
        baddies[i].kill();
    }

    if (baddyMesh) {
        baddyMesh.instanceMatrix.needsUpdate = true;
        baddyMesh.instanceColor.needsUpdate = true;
    }
}

var discMesh;
var discAnimation;

function loadSpinDisc() {
    loader.load( './spindisc.glb', (spindisc) => {
    
    //gltf.position.set(0, -100, 0);

    let spindiscMeshLocal, spindiscMaterialLocal;

    
    spindiscMaterialLocal = new THREE.MeshPhysicalMaterial();
    spindiscMaterialLocal.reflectivity = 0.5;
    spindiscMaterialLocal.transmission = 0.5;
    spindiscMaterialLocal.roughness = 0.2;
    spindiscMaterialLocal.metalness = 0.9;
    spindiscMaterialLocal.clearcoat = 0.3;
    spindiscMaterialLocal.clearcoatRoughness = 0.25;
    spindiscMaterialLocal.color = new THREE.Color(0xffffff);
    spindiscMaterialLocal.ior = 1.2;
    spindiscMaterialLocal.thickness = 5.0;

    spindisc.scene.traverse( function ( child ) {
        if ( child.isMesh ) {
            spindiscMeshLocal = child;
            child.material = spindiscMaterialLocal;
            //spindiscMaterialLocal = child.material;
            child.castShadow = true;
            child.receiveShadow = true;

            if ( child.material.map ) {
                child.material.map.anisotropy = 4;
            }
        }
    } );

    let mixer = new THREE.AnimationMixer( spindisc.scene );
    discAnimation = spindisc.animations[0];
    let discAction = mixer.clipAction( discAnimation );
    discAction.setLoop(THREE.LoopRepeat);
    discAction.play();
    playerMixers.push(mixer);

    scene.add( spindisc.scene );

    /*
    loader.load( './tornadobullshit.glb', (tornado) => {
    
    //gltf.position.set(0, -100, 0);

    tornado.scene.traverse( function ( child ) {
        if ( child.isMesh ) {
            child.castShadow = true;
            child.receiveShadow = true;
        }
    } );

    let mixer = new THREE.AnimationMixer( tornado.scene );
    let tornadoAnim = tornado.animations[0];
    let tornadoAction = mixer.clipAction( tornadoAnim );
    tornadoAction.setLoop(THREE.LoopRepeat);
    tornadoAction.play();
    playerMixers.push(mixer);

    scene.add( tornado.scene );

    } );
    */



    return;

    discMesh = new THREE.InstancedMesh(spindiscMeshLocal.geometry, spindiscMaterialLocal, NUM_SPHERES);
    discMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

    let px, py, pz;
    for(let i = 0; i < NUM_SPHERES; i++) {
        let newdisc = {
            index: i,
            position: [px, py, pz],
            collider: new THREE.Sphere( new THREE.Vector3( px, py, pz ), SPHERE_RADIUS),
            velocity: new THREE.Vector3(),
            revive: function() {
                this.position = [THREE.MathUtils.randFloat(-50, 50), THREE.MathUtils.randFloat(0, 25), THREE.MathUtils.randFloat(-50, 50) ];

                //console.log(`Setting baddie ${this.index}'s position to ${this.position}`);
                this.collider.center.set(...this.position);

                baddyDummy.position.set(...this.position);
                baddyDummy.updateMatrix();
                discMesh.setMatrixAt(this.index, baddyDummy.matrix);
            }
        };
        newdisc.revive(false);
        //baddies.push(newbaddie);
    }
    scene.add(discMesh);
    discMesh.instanceMatrix.needsUpdate = true;

});
}


for ( let i = 0; i < NUM_PLAYERS; i ++ ) {
    const ps = new THREE.Mesh( playerGeometry, playerMaterial.clone() );
    //const ps = clone(pantsGeometry);

    /*
    let moveToScene = null;
    ps.traverse( function ( child ) {
        if ( child.isSkinnedMesh ) {
            child.castShadow = true;
            child.material.skinning = true;
            moveToScene = child.skeleton.bones[0];
        }
    } );
    ps.animations = gltf.animations;
    moveToScene.rotation.set(0, 0, 0);
    moveToScene.position.set(0, -100, 0);
    moveToScene.scale.set(PLAYER_RADIUS, PLAYER_RADIUS, PLAYER_RADIUS);
    scene.add(moveToScene);
    mixer = new THREE.AnimationMixer( ps );
    mixer.clipAction( ps.animations[ 0 ] ).play();
    playerMixers.push(mixer);

    */

    ps.position.set(0, -100, 0);
    ps.castShadow = true;
    ps.receiveShadow = true;

    scene.add( ps );



    playerSpheres.push( {
        mesh: ps,
        collider: new THREE.Sphere( new THREE.Vector3( 0, - 100, 0 ), PLAYER_RADIUS ),
        velocity: new THREE.Vector3()
    } );
}



const audioListener = new THREE.AudioListener();
camera.add(audioListener);

const posSound1 = new THREE.PositionalAudio (audioListener);
const posSound2 = new THREE.PositionalAudio (audioListener);
const posSound3 = new THREE.PositionalAudio (audioListener);
let fireSoundPos = new THREE.Object3D();
let hitSoundPos = new THREE.Object3D();
let hitByBaddieSoundPos = new THREE.Object3D();
scene.add(fireSoundPos);
scene.add(hitSoundPos);
scene.add(hitByBaddieSoundPos);
fireSoundPos.add(posSound1);
hitSoundPos.add(posSound2);
hitByBaddieSoundPos.add(posSound3);

const audioLoader = new THREE.AudioLoader().setPath('./assets/audio/');

audioLoader.load('fire1.ogg', function(buffer) {
    posSound1.setBuffer(buffer);
    posSound1.setRefDistance(20);
    posSound1.play();
});

audioLoader.load('fire2.ogg', function(buffer) {
    posSound2.setBuffer(buffer);
    posSound2.setRefDistance(20);
    posSound2.play();
});


audioLoader.load('hitbybaddie.ogg', function(buffer) {
    posSound3.setBuffer(buffer);
    posSound3.setRefDistance(20);
    posSound3.play();
});

function playHitSoundAt(position) {
    hitSoundPos.position.copy(position);
    posSound2.stop();
    posSound2.play();
}

function playHitByBaddieSoundAt(position) {
    hitByBaddieSoundPos.position.copy(position);
    posSound3.stop();
    posSound3.play();
}


let channel = null;
let refreshRate = 50;
var playerRefresh;

function setPlayerRefresh(newRate) {
    refreshRate = Number(newRate);
    if (playerRefresh) {
        clearInterval(playerRefresh);
    }

    playerRefresh = setInterval(() => {
        //if (playerPos[0] != lastPlayerPos[0] || playerPos[1] != lastPlayerPos[1])
        /*
        if (true)
        {
            setplayer(playerPos[0], playerPos[1]);
            lastPlayerPos[0] = playerPos[0];
            lastPlayerPos[1] = playerPos[1];
        }
        */

        if (channel) {

            channel.emit('setplayer', GetLocalPlayerData());
            //channel.emit("getplayers", true);
        }

    }, refreshRate);
}


let pos = new THREE.Vector3();
let dir = new THREE.Vector3();
let vel = new THREE.Vector3();

function getFakePlayerFire(f) {
    return {
        direction: f.dir,
        collider: {
            end: f.pos,
            radius: PLAYER_RADIUS * 1.5
        },
        velocity: f.vel,
        id: f.id,
        color: f.color
    }

}

function GetLocalPlayerFire() {
    pos.copy(localplayer.collider.end);
    camera.getWorldDirection( dir );
    //.copy(localplayer.direction);
    vel.copy(localplayer.velocity);
    return {
        pos: pos,
        dir: dir,
        vel: vel,
        id: localplayer.id,
        color: localplayer.color
    };
}

function GetLocalPlayerData() {
    let pos = new THREE.Vector3();
    localplayer.collider.getCenter(pos);
    return {
        pos: pos,
        color: localplayer.color,
        health: localplayer.health
    };
}

var players = {}
var localplayer = null;

// Latency checking
var playerSentTime = null;
var playerReceiveTime = null;
var playerLagTime = null;

let devConfig = {
    port: 4121,
    url: "http://localhost"
};

let prodConfig = {
    port: 443,
    url: "https://2ths1m.com/ggj23-server/"
};

function establishChannel(isDev = true) {
    if (isDev) {
        channel = geckos(devConfig);
    }
    else {
        channel = geckos(prodConfig);
    }

    // once the channel is connected to the server
    channel.onConnect(error => {
        if (error) console.error(error.message)

        // listens for a disconnection
        channel.onDisconnect(() => {})

        channel.on('gamestate', function(data) {
            gameState.set(data);
        })

        channel.on('nextLevel', function(data) {
            gameState.set(data);
            resetBaddies();
        })

        channel.emit('nextLevel');

        // listens for a custom event from the server
        channel.on('chat message', function(data) {
            console.log(JSON.stringify(data));
        });

        channel.on('getplayers', function(data) {
            players = data;
        });

        channel.on('setplayer', function(data) {
            players[data.id] = data;
        });

        channel.on('lagmebro', function(data) {
            playerReceiveTime = new Date();
            playerLagTime = playerReceiveTime - playerSentTime;
        });

        channel.on('kill', function(data) {
            baddies[data].kill();
        });

        channel.on('revive', function(data) {
            baddies[data].revive();
        });

        channel.on('fire', function(data) {
            if (data.id == localplayer.id) return;

            let fpos = new THREE.Vector3(); fpos.set(data.pos.x, data.pos.y, data.pos.z);
            let fdir = new THREE.Vector3(); fdir.set(data.dir.x, data.dir.y, data.dir.z);
            let fvel = new THREE.Vector3(); fvel.set(data.vel.x, data.vel.y, data.vel.z);


            throwBall({
                direction: fdir,
                collider: {
                    end: fpos,
                    radius: PLAYER_RADIUS * 1.5
                },
                velocity: fvel,
                id: data.id,
                color: data.color
            });

        });

        channel.emit('makeplayer', 'heh');

        localplayer.id = channel.id;

        console.log("it worked?");
    });
}

function getRandomInt(max) {
  return Math.floor(Math.random() * max);
}

function getRandomColorHex() {
    const digits = "0123456789abcdef";
    let bgColor = "#";

    for(let i = 0; i < 6; i++) {
        bgColor += digits[getRandomInt(16)];
    }

    return bgColor;
}

function makeLocalPlayer() {
    localplayer = {
        collider: new Capsule(
            new THREE.Vector3( 0, 0.35, 0 ),    // start
            new THREE.Vector3( 0, 1, 0 ),       // end
            0.35 ),                             // radius
        velocity: new THREE.Vector3(),
        direction: new THREE.Vector3(),
        onFloor: false,
        jetting: false,
        jetjuice: 100,
        health: 100,
        id: -1,
        color: getRandomColorHex(),
    };
    establishChannel(location.hostname == "localhost");
    setPlayerRefresh(refreshRate);
    console.log("it's all gooooood!");

    //players.push(newplayer);
    //return newplayer;
}

const worldOctree = new Octree();

/*
const playerCollider = new Capsule( new THREE.Vector3( 0, 0.35, 0 ), new THREE.Vector3( 0, 1, 0 ), 0.35 );

const playerVelocity = new THREE.Vector3();
const playerDirection = new THREE.Vector3();

let playerOnFloor = false;
*/
let mouseTime = 0;

const keyStates = {};
const mouseStates = {};

const vector1 = new THREE.Vector3();
const vector2 = new THREE.Vector3();
const vector3 = new THREE.Vector3();

document.addEventListener( 'keydown', ( event ) => {

    keyStates[ event.code ] = true;

} );

document.addEventListener( 'keyup', ( event ) => {

    keyStates[ event.code ] = false;

} );

container.addEventListener( 'mousedown', (event) => {

    document.body.requestPointerLock();

    mouseTime = performance.now();

} );

document.addEventListener( 'mousedown', (event) => {

    mouseStates[ event.button ] = true;

} );

document.addEventListener( 'mouseup', (event) => {

    if ( document.pointerLockElement !== null ) {
        if ( event.button != 0) {
            let f = GetLocalPlayerFire();
            channel.emit('fire', f);
            throwBall(getFakePlayerFire(f));
        }
    }

    mouseStates[ event.button ] = false;
} );

document.body.addEventListener( 'mousemove', ( event ) => {

    if ( document.pointerLockElement === document.body ) {

        camera.rotation.y -= event.movementX / 500;
        camera.rotation.x -= event.movementY / 500;

    }

} );

window.addEventListener( 'resize', onWindowResize );

function onWindowResize() {

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize( window.innerWidth, window.innerHeight );

}

function throwBall(player) {

    const sphere = spheres[ sphereIdx ];
    sphere.active = true;
    sphere.id = player.id;

    sphere.mesh.material.color.set(player.color);

    sphere.collider.center.copy( player.collider.end ).addScaledVector( player.direction, player.collider.radius * 1.5 );

    // throw the ball with more force if we hold the button longer, and if we move forward

    //const impulse = 15 + 30 * ( 1 - Math.exp( ( mouseTime - performance.now() ) * 0.001 ) );
    const impulse = 91;

    sphere.velocity.copy( player.direction ).multiplyScalar( impulse );
    sphere.velocity.addScaledVector( player.velocity, 2 );

    if (fireSoundPos && posSound1 && posSound2) {
        fireSoundPos.position.copy(sphere.collider.center);
        posSound1.stop();
        posSound1.play();

        if (THREE.MathUtils.randInt(0, 20) > 1) {

        }
        else {
            posSound2.stop();
            posSound2.play();
        }

    }

    sphereIdx = ( sphereIdx + 1 ) % spheres.length;

}

function playerCollisions(player, isBaddie = false) {

    let result;
    if (isBaddie) {
        result = worldOctree.sphereIntersect(player.collider);
    }
    else {
        result = worldOctree.capsuleIntersect( player.collider );
    }

    player.onFloor = false;

    if ( result ) {

        player.onFloor = result.normal.y > 0;

        if ( ! player.onFloor ) {

            player.velocity.addScaledVector( result.normal, - result.normal.dot( player.velocity ) );

        }

        player.collider.translate( result.normal.multiplyScalar( result.depth ) );

    }

}

function updateLocalPlayer( deltaTime ) {

    let damping = Math.exp( - 4 * deltaTime ) - 1;

    const JETJUICE_RATE = 75;
    const JETFORCE = GRAVITY * 1.3;

    if ( ! localplayer.onFloor ) {

        localplayer.velocity.y -= GRAVITY * deltaTime;

        // small air resistance
        damping *= 0.1;

        if (localplayer.jetting && localplayer.jetjuice > 0) {
            localplayer.velocity.y += JETFORCE * deltaTime;
            //damping *= 0.5;

            localplayer.jetjuice -= deltaTime * JETJUICE_RATE;
        }
    }

    if (!localplayer.jetting && localplayer.jetjuice < 100) {
        localplayer.jetjuice += deltaTime * JETJUICE_RATE;
    }

    let juiceDisplay = Math.floor(localplayer.jetjuice);

    let hudText = "Health: " + localplayer.health + " ";
    //hud.innerHTML = `Juice: ${juiceDisplay}`;

    if ( keyStates['ShiftLeft'] ) {
        damping = 0.;
        hudText += `JUICE: ${juiceDisplay}`;
    } else {
        hudText += `Juice: ${juiceDisplay}`;
    }

    hudText += `<br>Badjos remaining: ` + gameState.getBaddiesRemaining();
    hudText += `<br>Waves cleared: ${gameState.wavesCleared}`;
    if (gameState.clearedIn > 0)
    {
        hudText += `<br>Last wave cleared in: ` + gameState.clearedIn.toFixed(2) + " s";
    }


    hud.innerHTML = hudText;

    localplayer.velocity.addScaledVector( localplayer.velocity, damping );

    const deltaPosition = localplayer.velocity.clone().multiplyScalar( deltaTime );
    localplayer.collider.translate( deltaPosition );

    playerCollisions(localplayer);

    camera.position.copy( localplayer.collider.end );

}

function updateRemotePlayers( deltaTime ) {
    let c = new THREE.Vector3();

    playerSphereIdx = 0;

    for (let pid in players) {
        if (pid == localplayer.id) continue;
        let player = players[pid];
        c.set(player.pos.x, player.pos.y, player.pos.z);
        let ps = playerSpheres[playerSphereIdx++];
        ps.mesh.position.copy(c);

        ps.mesh.traverse( function ( child ) {
            if ( child.isSkinnedMesh ) {
                //child.material
                child.material.color.set(player.color);
                child.skeleton.bones[0].position.set(player.pos.x, player.pos.y, player.pos.z);
            }
        } );
        if (ps.mesh.material != undefined) {
            ps.mesh.material.color.set(player.color);
        }

    }
}

function playerSphereCollision( player, sphere, isBaddie = false, isSphereBaddie = false) {

    let center;
    let points = [];

    if (isBaddie) {
        center = player.collider.center;
        points = [center];
    }
    else {
        if (player.id == sphere.id) return;
        center = vector1.addVectors( player.collider.start, player.collider.end ).multiplyScalar( 0.5 );
        points =  [ player.collider.start, player.collider.end, center ];
    }

    const sphere_center = sphere.collider.center;

    const r = player.collider.radius + sphere.collider.radius;
    const r2 = r * r;

    // approximation: player = 3 spheres

    for ( const point of points ) {

        const d2 = point.distanceToSquared( sphere_center );

        if ( d2 < r2 ) {

            const normal = vector1.subVectors( point, sphere_center ).normalize();
            const v1 = vector2.copy( normal ).multiplyScalar( normal.dot( player.velocity ) );
            const v2 = vector3.copy( normal ).multiplyScalar( normal.dot( sphere.velocity ) );

            player.velocity.add( v2 ).sub( v1 );
            sphere.velocity.add( v1 ).sub( v2 );

            

            if (isBaddie) {
                player.health -= 34;
                playHitSoundAt(sphere_center);
            }
            else {
                player.health -= 10;
                if (isSphereBaddie) {
                    sphere.health -= 100;
                    playHitByBaddieSoundAt(sphere_center);
                }
                else {
                    playHitSoundAt(sphere_center);
                }
            }

            const d = ( r - Math.sqrt( d2 ) ) / 2;
            sphere_center.addScaledVector( normal, - d );
        }
    }
}

function spheresCollisions() {

    for ( let i = 0, length = spheres.length; i < length; i ++ ) {

        const s1 = spheres[ i ];

        if (!s1.active) continue;

        for ( let j = i + 1; j < length; j ++ ) {

            const s2 = spheres[ j ];

            if (!s2.active) continue;

            if (s1.id == s2.id) continue;

            const d2 = s1.collider.center.distanceToSquared( s2.collider.center );
            const r = s1.collider.radius + s2.collider.radius;
            const r2 = r * r;

            if ( d2 < r2 ) {

                const normal = vector1.subVectors( s1.collider.center, s2.collider.center ).normalize();
                const v1 = vector2.copy( normal ).multiplyScalar( normal.dot( s1.velocity ) );
                const v2 = vector3.copy( normal ).multiplyScalar( normal.dot( s2.velocity ) );

                s1.velocity.add( v2 ).sub( v1 );
                s2.velocity.add( v1 ).sub( v2 );

                const d = ( r - Math.sqrt( d2 ) ) / 2;

                s1.collider.center.addScaledVector( normal, d );
                s2.collider.center.addScaledVector( normal, - d );

            }

        }

    }

}

function updateSpheres( deltaTime ) {

    spheres.forEach( sphere => {
        if (!sphere.active) return;
        sphere.collider.center.addScaledVector( sphere.velocity, deltaTime );

        if (sphere.collider.center.y < WATER_PLANE_HEIGHT) {
            sphere.active = false;
            return;
        }
        // if ((200 * 200) < sphere.collider.center.lengthSq()) {
        //     sphere.active = false;
        //     return;
        // }

        const result = worldOctree.sphereIntersect( sphere.collider );

        if ( result ) {

            sphere.velocity.addScaledVector( result.normal, - result.normal.dot( sphere.velocity ) * 1.5 );
            sphere.collider.center.add( result.normal.multiplyScalar( result.depth ) );

        }
        // else {
        //
        //     sphere.velocity.y -= GRAVITY * deltaTime;
        //
        // }

        // const damping = Math.exp( - 1.5 * deltaTime ) - 1;
        const damping = 0;
        sphere.velocity.addScaledVector( sphere.velocity, damping );

        /*
        players.forEach(player => {
            playerSphereCollision( player, sphere );
        })
        */

        playerSphereCollision( localplayer, sphere );

        baddies.forEach(baddie => {
            playerSphereCollision(baddie, sphere, true);
        });

    } );

    spheresCollisions();

    for ( const sphere of spheres ) {

        sphere.mesh.position.copy( sphere.collider.center );

    }

}

function updateBaddies( deltaTime ) {

    if (!baddyMesh) return;

    let damping = Math.exp( - 4 * deltaTime ) - 1;

    for(let i = 0; i < NUM_BADDIES; i++) {
        let badjo = baddies[i];

        if (!badjo.active) continue;

        if (badjo.health <= 0 && badjo.active) {
            badjo.kill(true);   // tell the world about our kill
            if (gameState.getBaddiesRemaining() < NUM_BADDIES) {
                badjo.revive(true); // tell the world about our mercy
            }
        }
        else {
            // Accumulate velocity sources
            playerCollisions(badjo, true);

            playerSphereCollision(localplayer, badjo, false, true);

            baddieLookAt.copy(localplayer.collider.end);
            baddieLookAt.subVectors(localplayer.collider.end, badjo.collider.center);
            baddieLookAt.normalize();
            baddieLookAt.multiplyScalar(BADDIE_SPEED);

            if (badjo.flies)
                badjo.velocity.copy(baddieLookAt);
            else
                badjo.velocity.addScaledVector(baddieLookAt, deltaTime * 5);

            badjo.velocity.addScaledVector( badjo.velocity, damping );



            //badjo.velocity.addScaledVector(baddieLookAt, deltaTime);

            // Apply velocity to position of collider
            const deltaPosition = badjo.velocity.clone().multiplyScalar( deltaTime );
            badjo.collider.translate( deltaPosition );

            if (badjo.collider.center.y <= WATER_PLANE_HEIGHT) {
                badjo.kill(true);
                if (gameState.getBaddiesRemaining() > NUM_BADDIES) {
                    badjo.revive(true); // tell the world about our mercy
                }
            }

            const result = worldOctree.sphereIntersect( badjo.collider );

            if ( result ) {

                badjo.velocity.addScaledVector( result.normal, - result.normal.dot( badjo.velocity ) * 1.5 );
                badjo.collider.center.add( result.normal.multiplyScalar( result.depth ) );

            } else {
                // These guys are wicked floaty!
                if (!badjo.flies)  badjo.velocity.y -= GRAVITY * WALKER_GRAV_MULTIPLIER * deltaTime;
            }
        }


        // Set instance mesh position to collider's position
        baddyDummy.position.set(...badjo.collider.center);
        baddyDummy.lookAt(localplayer.collider.end);
        baddyDummy.updateMatrix();
        baddyMesh.setMatrixAt(i, baddyDummy.matrix);

        if (badjo.health < 100)
        {
            let t = (100 - badjo.health) / 100;
            baddieCurrentColor.lerpColors(baddieFullColor, baddieDeadColor, t);
            baddyMesh.setColorAt(i, baddieCurrentColor);
        }
    }

    baddyMesh.instanceMatrix.needsUpdate = true;
    baddyMesh.instanceColor.needsUpdate = true;

    /*
    baddies.forEach( baddie => {
        baddie.mesh.lookAt (localplayer.collider.end);
        /*
        baddie.collider.center.addScaledVector( baddie.velocity, deltaTime );

        const result = worldOctree.sphereIntersect( baddie.collider );

        if ( result ) {

            baddie.velocity.addScaledVector( result.normal, - result.normal.dot( baddie.velocity ) * 1.5 );
            baddie.collider.center.add( result.normal.multiplyScalar( result.depth ) );

        } else {

            baddie.velocity.y -= GRAVITY * deltaTime;

        }

        const damping = Math.exp( - 1.5 * deltaTime ) - 1;
        baddie.velocity.addScaledVector( baddie.velocity, damping );


        players.forEach(player => {
            playerSphereCollision( player, sphere );
        })


        playerSphereCollision( localplayer, baddie );


    } );
    */

    //baddieCollisions();

    /*
    for ( const baddie of baddies ) {

        baddie.mesh.position.copy( baddie.collider.center );

    }
    */

}

function getForwardVector(player) {

    camera.getWorldDirection( player.direction );
    player.direction.y = 0;
    player.direction.normalize();

    return player.direction;

}

function getSideVector(player) {

    camera.getWorldDirection( player.direction );
    player.direction.y = 0;
    player.direction.normalize();
    player.direction.cross( camera.up );

    return player.direction;
}

function gamepadControls(deltaTime) {
    //console.log(JSON.stringify(pad.buttons));
    //console.log(JSON.stringify(pad.axes));

    let deadzone = 0.2;

    const speedDelta = deltaTime * ( localplayer.onFloor ? 25 : 8 );

    if ( pad.axes[1] < -deadzone)
    {
        localplayer.velocity.add( getForwardVector(localplayer).multiplyScalar( speedDelta ) );
    }

    if ( pad.axes[1] > deadzone)
    {
        localplayer.velocity.add( getForwardVector(localplayer).multiplyScalar( - speedDelta ) );
    }

    if ( pad.axes[0] < -deadzone)
    {
        localplayer.velocity.add( getSideVector(localplayer).multiplyScalar( - speedDelta ) );
    }

    if ( pad.axes[0] > deadzone)
    {
        localplayer.velocity.add( getSideVector(localplayer).multiplyScalar( speedDelta ) );
    }

    if ( pad.buttons[6].pressed )
    {
        if ( localplayer.onFloor) {
            localplayer.velocity.y = 15;
        }
        else {
            localplayer.jetting = true;
        }
    }

    if ( pad.buttons[7].pressed)
    {
        if ( BALL_REFIRE_RATE < time_since_last_ball ) {
            time_since_last_ball = 0.;

            let f = GetLocalPlayerFire();
            channel.emit('fire', f);
            throwBall(getFakePlayerFire(f));
        }
    }

    if (Math.abs(pad.axes[2]) > deadzone) {
        camera.rotation.y -= pad.axes[2] / 250;
    }
    if (Math.abs(pad.axes[3]) > deadzone) {
        camera.rotation.x -= pad.axes[3] / 250;
    }

}

function controls( deltaTime ) {



    //Gamepads.update();

    // gives a bit of air control
    const speedDelta = deltaTime * ( localplayer.onFloor ? 25 : 8 );

    time_since_last_ball += deltaTime;

    localplayer.jetting = false;

    if (pad) {
        gamepadControls(deltaTime);
    }

    if ( keyStates[ 'KeyW' ] ) {

        localplayer.velocity.add( getForwardVector(localplayer).multiplyScalar( speedDelta ) );

    }

    if ( keyStates[ 'KeyS' ] ) {

        localplayer.velocity.add( getForwardVector(localplayer).multiplyScalar( - speedDelta ) );

    }

    if ( keyStates[ 'KeyA' ] ) {

        localplayer.velocity.add( getSideVector(localplayer).multiplyScalar( - speedDelta ) );

    }

    if ( keyStates[ 'KeyD' ] ) {

        localplayer.velocity.add( getSideVector(localplayer).multiplyScalar( speedDelta ) );

    }

    if ( keyStates[ 'Space' ] ) {
        if ( localplayer.onFloor) {
            localplayer.velocity.y = 15;
        }
        else {
            localplayer.jetting = true;
        }
    }

    if ( mouseStates[0] ) {
      if ( BALL_REFIRE_RATE < time_since_last_ball ) {
        time_since_last_ball = 0.;

        let f = GetLocalPlayerFire();
        channel.emit('fire', f);
        throwBall(getFakePlayerFire(f));
      }
    }


}

var pause = false;

loader.load( 'haus2x.gltf.glb', ( gltf ) => {

    scene.add( gltf.scene );

    worldOctree.fromGraphNode( gltf.scene );

    gltf.scene.traverse( child => {

        if ( child.isMesh ) {

            child.castShadow = true;
            child.receiveShadow = true;

            child.material = new THREE.MeshPhongMaterial({
                color: 0x4444BB,
                flatShading: false
            })

            if ( child.material.map ) {

                child.material.map.anisotropy = 4;

            }

        }

    } );

    const helper = new OctreeHelper( worldOctree );
    helper.visible = false;
    scene.add( helper );

    makeLocalPlayer(true);

    const gui = new GUI( { width: 200 } );
    gui.add( { pause: false}, 'pause')
        .onChange( function (value) {
            pause = value;
            if (!pause) {
                requestAnimationFrame( animate );
            }
        });

    gui.add( { stats: true}, 'stats')
        .onChange( function (value) {
            stats.domElement.style.visibility =  value ? "visible" : "hidden";
        });
    gui.add( { debug: false }, 'debug' )
        .onChange( function ( value ) {
            helper.visible = value;
        } );

    gui.add( { refreshRate: 50 }, 'refreshRate')
        .onChange( function (value) {
            refreshRate = value;
            setPlayerRefresh(refreshRate);
        })
    gui.addColor( { color: localplayer.color}, 'color')
        .onChange ( function (value) {
            localplayer.color = value;
        })
    const bp = gui.addFolder("baddie position");
    bp.add( { x : 0}, 'x')
        .onChange(function(value) {
            baddies[0].mesh.position.setComponent(0, value);
        });
    bp.add( { y : 0}, 'y')
        .onChange(function(value) {
            baddies[0].mesh.position.setComponent(1, value);
        });

    bp.add( { z : 0}, 'z')
        .onChange(function(value) {
            baddies[0].mesh.position.setComponent(2, value);
        });




    animate();

} );

function teleportPlayerIfOob() {

    if ( camera.position.y <= WATER_PLANE_HEIGHT ) {

        localplayer.collider.start.set( 0, 0.35, 0 );
        localplayer.collider.end.set( 0, 1, 0 );
        localplayer.collider.radius = 0.35;
        camera.position.copy( localplayer.collider.end );
        camera.rotation.set( 0, 0, 0 );

    }

}

function animate() {

    const deltaTime = Math.min( 0.05, clock.getDelta() ) / STEPS_PER_FRAME;

    // we look for collisions in substeps to mitigate the risk of
    // an object traversing another too quickly for detection.

    for(const p of navigator.getGamepads()) {
        pad = p;
        break;
    }

    for ( let i = 0; i < STEPS_PER_FRAME; i ++ ) {

        controls( deltaTime );

        updateLocalPlayer( deltaTime );

        updateRemotePlayers( deltaTime );

        updateSpheres( deltaTime );

        updateBaddies(deltaTime);

        teleportPlayerIfOob();

    }

    water.material.uniforms[ 'time' ].value += deltaTime * STEPS_PER_FRAME;

    renderer.render( scene, camera );

    stats.update();

    let cd = clock.getDelta() ;
    playerMixers.forEach(mixer => {
        mixer.update(cd );
    });

    if (!pause) {
        requestAnimationFrame( animate );
    }



}

		</script>
	</body>
</html>
