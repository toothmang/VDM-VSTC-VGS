<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js - misc - octree collisions</title>
		<meta charset=utf-8 />
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
        <script src="./lib/geckos.io-client.2.3.0.min.js"></script>
	</head>
	<body>
        <div id="hud">HUD</div>
		<div id="container"></div>

		<!-- Import maps polyfill -->
		<!-- Remove this when import maps will be widely supported -->
		<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

		<script type="importmap">
			{
				"imports": {
					"three": "./lib/three.module.js",
					"three/addons/": "./lib/jsm/"
				}
			}
		</script>

		<script type="module">

import * as THREE from 'three';
import Stats from 'three/addons/libs/stats.module.js';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { Octree } from 'three/addons/math/Octree.js';
import { OctreeHelper } from 'three/addons/helpers/OctreeHelper.js';
import { Capsule } from 'three/addons/math/Capsule.js';
import { clone } from 'three/addons/utils/SkeletonUtils.js';
import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
import { Water } from 'three/addons/objects/Water.js';
import { Sky } from 'three/addons/objects/Sky.js';

const clock = new THREE.Clock();
const scene = new THREE.Scene();

scene.background = new THREE.Color( 0x88ccee );
scene.fog = new THREE.Fog( 0x88ccee, 0, 150 );

const camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 1000 );
camera.rotation.order = 'YXZ';

const fillLight1 = new THREE.HemisphereLight( 0x4488bb, 0x002244, 0.5 );
fillLight1.position.set( 2, 1, 1 );
scene.add( fillLight1 );

const solar = {
	elevation: 2,
	azimuth: 180,
    radius: 100
};

let phi = THREE.MathUtils.degToRad( 90 - solar.elevation );
let theta = THREE.MathUtils.degToRad( solar.azimuth );

const directionalLight = new THREE.DirectionalLight( 0xffffff, 0.8 );
directionalLight.position.setFromSphericalCoords( solar.radius, phi, theta );
directionalLight.castShadow = true;
directionalLight.shadow.camera.near = 0.01;
directionalLight.shadow.camera.far = 500;
directionalLight.shadow.camera.right = 30;
directionalLight.shadow.camera.left = - 30;
directionalLight.shadow.camera.top	= 30;
directionalLight.shadow.camera.bottom = - 30;
directionalLight.shadow.mapSize.width = 1024;
directionalLight.shadow.mapSize.height = 1024;
directionalLight.shadow.radius = 4;
directionalLight.shadow.bias = - 0.00006;
scene.add( directionalLight );

const container = document.getElementById( 'container' );
const hud = document.getElementById( 'hud' );

const renderer = new THREE.WebGLRenderer( { antialias: true } );
renderer.setPixelRatio( window.devicePixelRatio );
renderer.setSize( window.innerWidth, window.innerHeight );
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.VSMShadowMap;
renderer.outputEncoding = THREE.sRGBEncoding;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
container.appendChild( renderer.domElement );

const stats = new Stats();
stats.domElement.style.position = 'absolute';
stats.domElement.style.top = '0px';
container.appendChild( stats.domElement );

const GRAVITY = 30;

const NUM_SPHERES = 100;
const SPHERE_RADIUS = 0.2;
const STEPS_PER_FRAME = 5;

const WATER_PLANE_HEIGHT = -15;

const sphereGeometry = new THREE.IcosahedronGeometry( SPHERE_RADIUS, 5 );
const sphereMaterial = new THREE.MeshLambertMaterial( { color: 0xbbbb44 } );

const NUM_PLAYERS = 10;
const PLAYER_RADIUS = 0.4;
var playerGeometry = new THREE.IcosahedronGeometry( PLAYER_RADIUS, 5 );
const playerMaterial = new THREE.MeshLambertMaterial( { color: 0x44aa22 } );

const BALL_REFIRE_RATE = 0.100; // 100 ms
let time_since_last_ball = 0;

const spheres = [];
let sphereIdx = 0;


for ( let i = 0; i < NUM_SPHERES; i ++ ) {
    const sphere = new THREE.Mesh( sphereGeometry, sphereMaterial.clone() );
    sphere.castShadow = true;
    sphere.receiveShadow = true;

    scene.add( sphere );

    spheres.push( {
        mesh: sphere,
        collider: new THREE.Sphere( new THREE.Vector3( 0, - 100, 0 ), SPHERE_RADIUS ),
        velocity: new THREE.Vector3()
    } );
}

const playerSpheres = [];
const playerMixers = [];
let animation = null;
let playerSphereIdx = 0;

let sun = new THREE.Vector3();
const waterGeometry = new THREE.PlaneGeometry( 10000, 10000 );
//waterGeometry.position.setY(-16.);
waterGeometry.translate(0., 0., WATER_PLANE_HEIGHT);
let water = new Water(
	waterGeometry,
	{
		textureWidth: 512,
		textureHeight: 512,
		waterNormals: new THREE.TextureLoader().load( 'assets/textures/waternormals.jpg', function ( texture ) {

			texture.wrapS = texture.wrapT = THREE.RepeatWrapping;

		} ),
		sunDirection: new THREE.Vector3(),
		sunColor: 0xffffff,
		waterColor: 0x004488, // tutorial nasty-water color is 0x001e0f,
		distortionScale: 3.7,
		//fog: scene.fog !== undefined
        fog: false
	}
);

water.rotation.x = - Math.PI / 2;
scene.add( water );

// Skybox

const sky = new Sky();
sky.scale.setScalar( 10000 );
scene.add( sky );

const skyUniforms = sky.material.uniforms;

skyUniforms[ 'turbidity' ].value = 10;
skyUniforms[ 'rayleigh' ].value = 2;
skyUniforms[ 'mieCoefficient' ].value = 0.005;
skyUniforms[ 'mieDirectionalG' ].value = 0.8;

const pmremGenerator = new THREE.PMREMGenerator( renderer );
let renderTarget;

function updateSun() {

	const phi = THREE.MathUtils.degToRad( 90 - solar.elevation );
	const theta = THREE.MathUtils.degToRad( solar.azimuth );

	sun.setFromSphericalCoords( solar.radius, phi, theta );

	sky.material.uniforms[ 'sunPosition' ].value.copy( sun );
	water.material.uniforms[ 'sunDirection' ].value.copy( sun ).normalize();

	if ( renderTarget !== undefined ) renderTarget.dispose();

	renderTarget = pmremGenerator.fromScene( sky );

	scene.environment = renderTarget.texture;

}

updateSun();

let pantsGeometry = null;
let pantsSkinnedMesh = null;
let pantsAnimation = null;

const loader = new GLTFLoader().setPath( './assets/models/' );

loader.load( './SimpleSkinning.gltf', (gltf) => {
    //gltf.position.set(0, -100, 0);



    gltf.scene.traverse( function ( child ) {
        if ( child.isSkinnedMesh ) {
            child.castShadow = true;
            child.skeleton.bones[0].scale.set(SPHERE_RADIUS, SPHERE_RADIUS, SPHERE_RADIUS);
        }
    } );

    let mixer = new THREE.AnimationMixer( gltf.scene );
    pantsAnimation = gltf.animations[0];
    mixer.clipAction( pantsAnimation ).play();
    playerMixers.push(mixer);

    let pantsGroup = new THREE.Group();
    pantsGroup.add(gltf.scene);
    pantsGroup.position.set(0.9, -1, 0);
    pantsGeometry = pantsGroup;
    pantsSkinnedMesh = gltf.scene;

    scene.add( pantsGroup );


    loadBaddies();
});

//var baddieGeometry = new THREE.IcosahedronGeometry( PLAYER_RADIUS, 5 );
const baddyDummy = new THREE.Object3D();
const NUM_BADDIES = 200;
var baddyMesh;
var baddieIdx = 0;
var baddies = [];

const cloneGltf = (gltf) => {
  const clone = {
    animations: gltf.animations,
    scene: gltf.scene.clone(true)
  };

  const skinnedMeshes = {};

  gltf.scene.traverse(node => {
    if (node.isSkinnedMesh) {
      skinnedMeshes[node.name] = node;
    }
  });

  const cloneBones = {};
  const cloneSkinnedMeshes = {};

  clone.scene.traverse(node => {
    if (node.isBone) {
      cloneBones[node.name] = node;
    }

    if (node.isSkinnedMesh) {
      cloneSkinnedMeshes[node.name] = node;
    }
  });

  for (let name in skinnedMeshes) {
    const skinnedMesh = skinnedMeshes[name];
    const skeleton = skinnedMesh.skeleton;
    const cloneSkinnedMesh = cloneSkinnedMeshes[name];

    const orderedCloneBones = [];

    for (let i = 0; i < skeleton.bones.length; ++i) {
      const cloneBone = cloneBones[skeleton.bones[i].name];
      orderedCloneBones.push(cloneBone);
    }

    cloneSkinnedMesh.bind(
        new THREE.Skeleton(orderedCloneBones, skeleton.boneInverses),
        cloneSkinnedMesh.matrixWorld);
  }

  return clone;
}

function loadBaddies() {
    loader.load( './baddie.glb', (baddie) => {
    //scene.add( baddie.scene );

    //gltf.position.set(0, -100, 0);

    let badStuff = baddie.scene;

    let baddieMeshLocal, baddieMaterialLocal;

    baddie.scene.traverse( function ( child ) {
        if ( child.isMesh ) {
            baddieMeshLocal = child;
            baddieMaterialLocal = child.material;
            badStuff = child;
            child.castShadow = true;
            child.receiveShadow = true;

            if ( child.material.map ) {
                child.material.map.anisotropy = 4;
            }
        }
    } );

    baddyMesh = new THREE.InstancedMesh(baddieMeshLocal.geometry, baddieMaterialLocal, NUM_BADDIES);
    baddyMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

    let px, py, pz;
    for(let i = 0; i < NUM_BADDIES; i++) {
        px = THREE.MathUtils.randFloat(-50, 50);
        py = THREE.MathUtils.randFloat(0, 25);
        pz = THREE.MathUtils.randFloat(-50, 50);
        baddies.push( {
            position: [px, py, pz],
            collider: new THREE.Sphere( new THREE.Vector3( px, py, pz ), PLAYER_RADIUS * 3),
            velocity: new THREE.Vector3()
        });
        baddyDummy.position.set(px, py, pz);
        baddyDummy.updateMatrix();

        baddyMesh.setMatrixAt(i, baddyDummy.matrix);
    }
    scene.add(baddyMesh);

    baddyMesh.instanceMatrix.needsUpdate = true;

    /*
    const badboi = badStuff.clone();
    //badboi.scale.set(0.1, 0.1, 0.1);
    //badboi.position.set(0, -100, 0);

    const badGroup = new THREE.Group();
    badGroup.add(badboi);

    let clonedPants = clone(pantsSkinnedMesh);
    //scene.add(clonedPants);

    let pantsGroup = new THREE.Group();
    pantsGroup.add(clonedPants);
    pantsGroup.position.set(0.9, -1, 0);
    scene.add(pantsGroup);

    badGroup.add(pantsGroup);

    //badboi.add(pantsGeometry);

    scene.add( badGroup );

    let mixer = new THREE.AnimationMixer( clonedPants );
    mixer.clipAction( pantsAnimation ).play();
    playerMixers.push(mixer);

    baddies.push( {
            mesh: badGroup,
            collider: new THREE.Sphere( new THREE.Vector3( 0, - 100, 0 ), PLAYER_RADIUS ),
            velocity: new THREE.Vector3()
        } );

    for ( let i = 0; i < NUM_BADDIES; i ++ ) {
        const bg = badGroup.clone();

        //bg.position.set(0, -100, 0);

        scene.add( bg );

        baddies.push( {
            mesh: bg,
            collider: new THREE.Sphere( new THREE.Vector3( 0, - 100, 0 ), PLAYER_RADIUS ),
            velocity: new THREE.Vector3()
        } );
    }
    */

});
}


for ( let i = 0; i < NUM_PLAYERS; i ++ ) {
    const ps = new THREE.Mesh( playerGeometry, playerMaterial.clone() );
    //const ps = clone(pantsGeometry);

    /*
    let moveToScene = null;
    ps.traverse( function ( child ) {
        if ( child.isSkinnedMesh ) {
            child.castShadow = true;
            child.material.skinning = true;
            moveToScene = child.skeleton.bones[0];
        }
    } );
    ps.animations = gltf.animations;
    moveToScene.rotation.set(0, 0, 0);
    moveToScene.position.set(0, -100, 0);
    moveToScene.scale.set(PLAYER_RADIUS, PLAYER_RADIUS, PLAYER_RADIUS);
    scene.add(moveToScene);
    mixer = new THREE.AnimationMixer( ps );
    mixer.clipAction( ps.animations[ 0 ] ).play();
    playerMixers.push(mixer);

    */

    ps.position.set(0, -100, 0);
    ps.castShadow = true;
    ps.receiveShadow = true;

    scene.add( ps );



    playerSpheres.push( {
        mesh: ps,
        collider: new THREE.Sphere( new THREE.Vector3( 0, - 100, 0 ), PLAYER_RADIUS ),
        velocity: new THREE.Vector3()
    } );
}






let channel = null;
let refreshRate = 50;
var playerRefresh;

function setPlayerRefresh(newRate) {
    refreshRate = Number(newRate);
    if (playerRefresh) {
        clearInterval(playerRefresh);
    }

    playerRefresh = setInterval(() => {
        //if (playerPos[0] != lastPlayerPos[0] || playerPos[1] != lastPlayerPos[1])
        /*
        if (true)
        {
            setplayer(playerPos[0], playerPos[1]);
            lastPlayerPos[0] = playerPos[0];
            lastPlayerPos[1] = playerPos[1];
        }
        */

        if (channel) {

            channel.emit('setplayer', GetLocalPlayerData());
            //channel.emit("getplayers", true);
        }

    }, refreshRate);
}


let pos = new THREE.Vector3();
let dir = new THREE.Vector3();
let vel = new THREE.Vector3();

function getFakePlayerFire(f) {
    return {
        direction: f.dir,
        collider: {
            end: f.pos,
            radius: PLAYER_RADIUS * 1.5
        },
        velocity: f.vel,
        color: f.color
    }

}

function GetLocalPlayerFire() {
    pos.copy(localplayer.collider.end);
    camera.getWorldDirection( dir );
    //.copy(localplayer.direction);
    vel.copy(localplayer.velocity);
    return {
        pos: pos,
        dir: dir,
        vel: vel,
        id: localplayer.id,
        color: localplayer.color
    };
}

function GetLocalPlayerData() {
    let pos = new THREE.Vector3();
    localplayer.collider.getCenter(pos);
    return {
        pos: pos,
        color: localplayer.color
    };
}

var players = {}
var localplayer = null;

// Latency checking
var playerSentTime = null;
var playerReceiveTime = null;
var playerLagTime = null;

let devConfig = {
    port: 4121,
    url: "http://localhost"
};

let prodConfig = {
    port: 443,
    url: "https://2ths1m.com/ggj23-server/"
};

function establishChannel(isDev = true) {
    if (isDev) {
        channel = geckos(devConfig);
    }
    else {
        channel = geckos(prodConfig);
    }

    // once the channel is connected to the server
    channel.onConnect(error => {
        if (error) console.error(error.message)

        // listens for a disconnection
        channel.onDisconnect(() => {})

        // listens for a custom event from the server
        channel.on('chat message', function(data) {
            console.log(JSON.stringify(data));
        });

        channel.on('getplayers', function(data) {
            players = data;
        });

        channel.on('setplayer', function(data) {
            players[data.id] = data;
        });

        channel.on('lagmebro', function(data) {
            playerReceiveTime = new Date();
            playerLagTime = playerReceiveTime - playerSentTime;
        });


        channel.on('fire', function(data) {
            if (data.id == localplayer.id) return;

            let fpos = new THREE.Vector3(); fpos.set(data.pos.x, data.pos.y, data.pos.z);
            let fdir = new THREE.Vector3(); fdir.set(data.dir.x, data.dir.y, data.dir.z);
            let fvel = new THREE.Vector3(); fvel.set(data.vel.x, data.vel.y, data.vel.z);


            throwBall({
                direction: fdir,
                collider: {
                    end: fpos,
                    radius: PLAYER_RADIUS * 1.5
                },
                velocity: fvel,
                color: data.color
            });

        });

        channel.emit('makeplayer', 'heh');

        localplayer.id = channel.id;

        console.log("it worked?");
    });
}

function getRandomInt(max) {
  return Math.floor(Math.random() * max);
}

function getRandomColorHex() {
    const digits = "0123456789abcdef";
    let bgColor = "#";

    for(let i = 0; i < 6; i++) {
        bgColor += digits[getRandomInt(16)];
    }

    return bgColor;
}

function makeLocalPlayer() {
    localplayer = {
        collider: new Capsule(
            new THREE.Vector3( 0, 0.35, 0 ),    // start
            new THREE.Vector3( 0, 1, 0 ),       // end
            0.35 ),                             // radius
        velocity: new THREE.Vector3(),
        direction: new THREE.Vector3(),
        onFloor: false,
        jetting: false,
        jetjuice: 100,
        id: -1,
        color: getRandomColorHex()
    };
    establishChannel(location.hostname == "localhost");
    setPlayerRefresh(refreshRate);
    console.log("it's all gooooood!");

    //players.push(newplayer);
    //return newplayer;
}

const worldOctree = new Octree();

/*
const playerCollider = new Capsule( new THREE.Vector3( 0, 0.35, 0 ), new THREE.Vector3( 0, 1, 0 ), 0.35 );

const playerVelocity = new THREE.Vector3();
const playerDirection = new THREE.Vector3();

let playerOnFloor = false;
*/
let mouseTime = 0;

const keyStates = {};
const mouseStates = {};

const vector1 = new THREE.Vector3();
const vector2 = new THREE.Vector3();
const vector3 = new THREE.Vector3();

document.addEventListener( 'keydown', ( event ) => {

    keyStates[ event.code ] = true;

} );

document.addEventListener( 'keyup', ( event ) => {

    keyStates[ event.code ] = false;

} );

container.addEventListener( 'mousedown', (event) => {

    document.body.requestPointerLock();

    mouseTime = performance.now();

} );

document.addEventListener( 'mousedown', (event) => {

    mouseStates[ event.button ] = true;

} );

document.addEventListener( 'mouseup', (event) => {

    if ( document.pointerLockElement !== null ) {
        if ( event.button != 0) {
            let f = GetLocalPlayerFire();
            channel.emit('fire', f);
            throwBall(getFakePlayerFire(f));
        }
    }

    mouseStates[ event.button ] = false;
} );

document.body.addEventListener( 'mousemove', ( event ) => {

    if ( document.pointerLockElement === document.body ) {

        camera.rotation.y -= event.movementX / 500;
        camera.rotation.x -= event.movementY / 500;

    }

} );

window.addEventListener( 'resize', onWindowResize );

function onWindowResize() {

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize( window.innerWidth, window.innerHeight );

}

function throwBall(player) {

    const sphere = spheres[ sphereIdx ];

    sphere.mesh.material.color.set(player.color);

    sphere.collider.center.copy( player.collider.end ).addScaledVector( player.direction, player.collider.radius * 1.5 );

    // throw the ball with more force if we hold the button longer, and if we move forward

    //const impulse = 15 + 30 * ( 1 - Math.exp( ( mouseTime - performance.now() ) * 0.001 ) );
    const impulse = 44;

    sphere.velocity.copy( player.direction ).multiplyScalar( impulse );
    sphere.velocity.addScaledVector( player.velocity, 2 );

    sphereIdx = ( sphereIdx + 1 ) % spheres.length;

}

function playerCollisions(player, isBaddie = false) {

    let result;
    if (isBaddie) {
        result = worldOctree.sphereIntersect(player.collider);
    }
    else {
        result = worldOctree.capsuleIntersect( player.collider );
    }

    player.onFloor = false;

    if ( result ) {

        player.onFloor = result.normal.y > 0;

        if ( ! player.onFloor ) {

            player.velocity.addScaledVector( result.normal, - result.normal.dot( player.velocity ) );

        }

        player.collider.translate( result.normal.multiplyScalar( result.depth ) );

    }

}

function updateLocalPlayer( deltaTime ) {

    let damping = Math.exp( - 4 * deltaTime ) - 1;

    const JETJUICE_RATE = 75;
    const JETFORCE = GRAVITY * 1.3;

    if ( ! localplayer.onFloor ) {

        localplayer.velocity.y -= GRAVITY * deltaTime;

        // small air resistance
        damping *= 0.1;

        if (localplayer.jetting && localplayer.jetjuice > 0) {
            localplayer.velocity.y += JETFORCE * deltaTime;
            //damping *= 0.5;

            localplayer.jetjuice -= deltaTime * JETJUICE_RATE;
        }
    }

    if (!localplayer.jetting && localplayer.jetjuice < 100) {
        localplayer.jetjuice += deltaTime * JETJUICE_RATE;
    }

    let juiceDisplay = Math.floor(localplayer.jetjuice);

    //hud.innerHTML = `Juice: ${juiceDisplay}`;

    if ( keyStates['ShiftLeft'] ) {
        damping = 0.;
        hud.innerHTML = `JUICE: ${juiceDisplay}`;
    } else {
        hud.innerHTML = `Juice: ${juiceDisplay}`;
    }

    localplayer.velocity.addScaledVector( localplayer.velocity, damping );

    const deltaPosition = localplayer.velocity.clone().multiplyScalar( deltaTime );
    localplayer.collider.translate( deltaPosition );

    playerCollisions(localplayer);

    camera.position.copy( localplayer.collider.end );

}

function updateRemotePlayers( deltaTime ) {
    let c = new THREE.Vector3();

    playerSphereIdx = 0;

    for (let pid in players) {
        if (pid == localplayer.id) continue;
        let player = players[pid];
        c.set(player.pos.x, player.pos.y, player.pos.z);
        let ps = playerSpheres[playerSphereIdx++];
        ps.mesh.position.copy(c);

        ps.mesh.traverse( function ( child ) {
            if ( child.isSkinnedMesh ) {
                //child.material
                child.material.color.set(player.color);
                child.skeleton.bones[0].position.set(player.pos.x, player.pos.y, player.pos.z);
            }
        } );
        if (ps.mesh.material != undefined) {
            ps.mesh.material.color.set(player.color);
        }

    }
}

function baddieSphereCollision( baddie, sphere ) {
    const center = baddie.collider.center;

    const sphere_center = sphere.collider.center;

    const r = baddie.collider.radius + sphere.collider.radius;
    const r2 = r * r;

    // approximation: player = 3 spheres

    for ( const point of [ center ] ) {

        const d2 = point.distanceToSquared( sphere_center );

        if ( d2 < r2 ) {

            const normal = vector1.subVectors( point, sphere_center ).normalize();
            const v1 = vector2.copy( normal ).multiplyScalar( normal.dot( baddie.velocity ) );
            const v2 = vector3.copy( normal ).multiplyScalar( normal.dot( sphere.velocity ) );

            baddie.velocity.add( v2 ).sub( v1 );
            sphere.velocity.add( v1 ).sub( v2 );

            const d = ( r - Math.sqrt( d2 ) ) / 2;
            sphere_center.addScaledVector( normal, - d );

        }
    }
}


function playerSphereCollision( player, sphere ) {

    const center = vector1.addVectors( player.collider.start, player.collider.end ).multiplyScalar( 0.5 );

    const sphere_center = sphere.collider.center;

    const r = player.collider.radius + sphere.collider.radius;
    const r2 = r * r;

    // approximation: player = 3 spheres

    for ( const point of [ player.collider.start, player.collider.end, center ] ) {

        const d2 = point.distanceToSquared( sphere_center );

        if ( d2 < r2 ) {

            const normal = vector1.subVectors( point, sphere_center ).normalize();
            const v1 = vector2.copy( normal ).multiplyScalar( normal.dot( player.velocity ) );
            const v2 = vector3.copy( normal ).multiplyScalar( normal.dot( sphere.velocity ) );

            player.velocity.add( v2 ).sub( v1 );
            sphere.velocity.add( v1 ).sub( v2 );

            const d = ( r - Math.sqrt( d2 ) ) / 2;
            sphere_center.addScaledVector( normal, - d );

        }

    }

}

function spheresCollisions() {

    for ( let i = 0, length = spheres.length; i < length; i ++ ) {

        const s1 = spheres[ i ];

        for ( let j = i + 1; j < length; j ++ ) {

            const s2 = spheres[ j ];

            const d2 = s1.collider.center.distanceToSquared( s2.collider.center );
            const r = s1.collider.radius + s2.collider.radius;
            const r2 = r * r;

            if ( d2 < r2 ) {

                const normal = vector1.subVectors( s1.collider.center, s2.collider.center ).normalize();
                const v1 = vector2.copy( normal ).multiplyScalar( normal.dot( s1.velocity ) );
                const v2 = vector3.copy( normal ).multiplyScalar( normal.dot( s2.velocity ) );

                s1.velocity.add( v2 ).sub( v1 );
                s2.velocity.add( v1 ).sub( v2 );

                const d = ( r - Math.sqrt( d2 ) ) / 2;

                s1.collider.center.addScaledVector( normal, d );
                s2.collider.center.addScaledVector( normal, - d );

            }

        }

    }

}

function baddieCollisions() {

for ( let i = 0, length = baddies.length; i < length; i ++ ) {

    const s1 = baddies[ i ];

    for ( let j = i + 1; j < length; j ++ ) {

        const s2 = baddies[ j ];

        const d2 = s1.collider.center.distanceToSquared( s2.collider.center );
        const r = s1.collider.radius + s2.collider.radius;
        const r2 = r * r;

        if ( d2 < r2 ) {

            const normal = vector1.subVectors( s1.collider.center, s2.collider.center ).normalize();
            const v1 = vector2.copy( normal ).multiplyScalar( normal.dot( s1.velocity ) );
            const v2 = vector3.copy( normal ).multiplyScalar( normal.dot( s2.velocity ) );

            s1.velocity.add( v2 ).sub( v1 );
            s2.velocity.add( v1 ).sub( v2 );

            const d = ( r - Math.sqrt( d2 ) ) / 2;

            s1.collider.center.addScaledVector( normal, d );
            s2.collider.center.addScaledVector( normal, - d );

        }

    }

}

}

function updateSpheres( deltaTime ) {

    spheres.forEach( sphere => {

        sphere.collider.center.addScaledVector( sphere.velocity, deltaTime );

        const result = worldOctree.sphereIntersect( sphere.collider );

        if ( result ) {

            sphere.velocity.addScaledVector( result.normal, - result.normal.dot( sphere.velocity ) * 1.5 );
            sphere.collider.center.add( result.normal.multiplyScalar( result.depth ) );

        } else {

            sphere.velocity.y -= GRAVITY * deltaTime;

        }

        const damping = Math.exp( - 1.5 * deltaTime ) - 1;
        sphere.velocity.addScaledVector( sphere.velocity, damping );

        /*
        players.forEach(player => {
            playerSphereCollision( player, sphere );
        })
        */

        playerSphereCollision( localplayer, sphere );

        baddies.forEach(baddie => {
            baddieSphereCollision(baddie, sphere);
        });

    } );

    spheresCollisions();

    for ( const sphere of spheres ) {

        sphere.mesh.position.copy( sphere.collider.center );

    }

}

const baddieLookAt = new THREE.Vector3();
function updateBaddies( deltaTime ) {

    if (!baddyMesh) return;



    for(let i = 0; i < NUM_BADDIES; i++) {
        let badjo = baddies[i];
        // Accumulate velocity sources 
        playerCollisions(badjo, true);

        baddieLookAt.copy(localplayer.collider.end);
        baddieLookAt.subVectors(localplayer.collider.end, badjo.collider.center);
        baddieLookAt.normalize();

        badjo.velocity.addScaledVector(baddieLookAt, deltaTime * 5);

        // Apply velocity to position of collider
        const deltaPosition = badjo.velocity.clone().multiplyScalar( deltaTime );
        badjo.collider.translate( deltaPosition );

        // Set instance mesh position to collider's position
        baddyDummy.position.set(...badjo.collider.center);
        baddyDummy.lookAt(localplayer.collider.end);
        baddyDummy.updateMatrix();
        baddyMesh.setMatrixAt(i, baddyDummy.matrix);
    }

    baddyMesh.instanceMatrix.needsUpdate = true;

    /*
    baddies.forEach( baddie => {
        baddie.mesh.lookAt (localplayer.collider.end);
        /*
        baddie.collider.center.addScaledVector( baddie.velocity, deltaTime );

        const result = worldOctree.sphereIntersect( baddie.collider );

        if ( result ) {

            baddie.velocity.addScaledVector( result.normal, - result.normal.dot( baddie.velocity ) * 1.5 );
            baddie.collider.center.add( result.normal.multiplyScalar( result.depth ) );

        } else {

            baddie.velocity.y -= GRAVITY * deltaTime;

        }

        const damping = Math.exp( - 1.5 * deltaTime ) - 1;
        baddie.velocity.addScaledVector( baddie.velocity, damping );


        players.forEach(player => {
            playerSphereCollision( player, sphere );
        })


        playerSphereCollision( localplayer, baddie );


    } );
    */

    //baddieCollisions();

    /*
    for ( const baddie of baddies ) {

        baddie.mesh.position.copy( baddie.collider.center );

    }
    */

}

function getForwardVector(player) {

    camera.getWorldDirection( player.direction );
    player.direction.y = 0;
    player.direction.normalize();

    return player.direction;

}

function getSideVector(player) {

    camera.getWorldDirection( player.direction );
    player.direction.y = 0;
    player.direction.normalize();
    player.direction.cross( camera.up );

    return player.direction;

}

function controls( deltaTime ) {

    // gives a bit of air control
    const speedDelta = deltaTime * ( localplayer.onFloor ? 25 : 8 );

    time_since_last_ball += deltaTime;

    if ( keyStates[ 'KeyW' ] ) {

        localplayer.velocity.add( getForwardVector(localplayer).multiplyScalar( speedDelta ) );

    }

    if ( keyStates[ 'KeyS' ] ) {

        localplayer.velocity.add( getForwardVector(localplayer).multiplyScalar( - speedDelta ) );

    }

    if ( keyStates[ 'KeyA' ] ) {

        localplayer.velocity.add( getSideVector(localplayer).multiplyScalar( - speedDelta ) );

    }

    if ( keyStates[ 'KeyD' ] ) {

        localplayer.velocity.add( getSideVector(localplayer).multiplyScalar( speedDelta ) );

    }

    if ( keyStates[ 'Space' ] ) {
        if ( localplayer.onFloor) {
            localplayer.velocity.y = 15;
        }
        else {
            localplayer.jetting = true;
        }
    }
    else {
        localplayer.jetting = false;
    }

    if ( mouseStates[0] ) {
      if ( BALL_REFIRE_RATE < time_since_last_ball ) {
        time_since_last_ball = 0.;

        let f = GetLocalPlayerFire();
        channel.emit('fire', f);
        throwBall(getFakePlayerFire(f));
      }
    }

}

loader.load( 'haus2x.gltf.glb', ( gltf ) => {

    scene.add( gltf.scene );

    worldOctree.fromGraphNode( gltf.scene );

    gltf.scene.traverse( child => {

        if ( child.isMesh ) {

            child.castShadow = true;
            child.receiveShadow = true;

            child.material = new THREE.MeshPhongMaterial({
                color: 0x4444BB,
                flatShading: false
            })

            if ( child.material.map ) {

                child.material.map.anisotropy = 4;

            }

        }

    } );

    const helper = new OctreeHelper( worldOctree );
    helper.visible = false;
    scene.add( helper );

    makeLocalPlayer(true);

    const gui = new GUI( { width: 200 } );
    gui.add( { stats: true}, 'stats')
        .onChange( function (value) {
            stats.domElement.style.visibility =  value ? "visible" : "hidden";
        });
    gui.add( { debug: false }, 'debug' )
        .onChange( function ( value ) {
            helper.visible = value;
        } );

    gui.add( { refreshRate: 50 }, 'refreshRate')
        .onChange( function (value) {
            refreshRate = value;
            setPlayerRefresh(refreshRate);
        })
    gui.addColor( { color: localplayer.color}, 'color')
        .onChange ( function (value) {
            localplayer.color = value;
        })
    const bp = gui.addFolder("baddie position");
    bp.add( { x : 0}, 'x')
        .onChange(function(value) {
            baddies[0].mesh.position.setComponent(0, value);
        });
    bp.add( { y : 0}, 'y')
        .onChange(function(value) {
            baddies[0].mesh.position.setComponent(1, value);
        });

    bp.add( { z : 0}, 'z')
        .onChange(function(value) {
            baddies[0].mesh.position.setComponent(2, value);
        });




    animate();

} );

function teleportPlayerIfOob() {

    if ( camera.position.y <= WATER_PLANE_HEIGHT ) {

        localplayer.collider.start.set( 0, 0.35, 0 );
        localplayer.collider.end.set( 0, 1, 0 );
        localplayer.collider.radius = 0.35;
        camera.position.copy( localplayer.collider.end );
        camera.rotation.set( 0, 0, 0 );

    }

}

function animate() {

    const deltaTime = Math.min( 0.05, clock.getDelta() ) / STEPS_PER_FRAME;

    // we look for collisions in substeps to mitigate the risk of
    // an object traversing another too quickly for detection.

    for ( let i = 0; i < STEPS_PER_FRAME; i ++ ) {

        controls( deltaTime );

        updateLocalPlayer( deltaTime );

        updateRemotePlayers( deltaTime );

        updateSpheres( deltaTime );

        updateBaddies(deltaTime);

        teleportPlayerIfOob();

    }

    water.material.uniforms[ 'time' ].value += deltaTime * STEPS_PER_FRAME;

    renderer.render( scene, camera );

    stats.update();


    playerMixers.forEach(mixer => {
        mixer.update( clock.getDelta() );
    });

    requestAnimationFrame( animate );


}

		</script>
	</body>
</html>
